package patterns

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func sampleInput() Input {
	return Input{
		ProjectName: "MyProject",
		Blueprint:   "A microservices architecture with an API gateway, auth service, and data layer backed by PostgreSQL.",
		Patterns: []string{
			"Dependency injection via constructor functions",
			"Interface-based abstractions for testability",
			"Context propagation for cancellation and tracing",
		},
		Zones: []Zone{
			{
				Name:   "authentication",
				Intent: "Handles user login, registration, and credential verification",
				Files:  []string{"auth/login.go", "auth/register.go", "auth/credentials.go"},
			},
			{
				Name:   "billing",
				Intent: "Manages subscriptions, invoices, and payment processing",
				Files:  []string{"billing/subscription.go", "billing/invoice.go"},
			},
		},
		Modules: []ModuleSummary{
			{
				Name:   "auth",
				Intent: "Provides authentication and session management",
				Type:   "go",
			},
			{
				Name:   "web-ui",
				Intent: "React-based frontend for the dashboard",
				Type:   "node",
			},
			{
				Name:   "ml-pipeline",
				Intent: "Data processing and model training pipeline",
				Type:   "python",
			},
		},
	}
}

func TestGenerateCLAUDE_ContainsSections(t *testing.T) {
	input := sampleInput()
	output := GenerateCLAUDE(input)

	// Project name as heading.
	if !strings.Contains(output, "# MyProject") {
		t.Error("output should contain project name heading")
	}

	// Architecture section with blueprint.
	if !strings.Contains(output, "## Architecture") {
		t.Error("output should contain Architecture section")
	}
	if !strings.Contains(output, "microservices architecture") {
		t.Error("output should contain the blueprint text")
	}

	// Modules section.
	if !strings.Contains(output, "## Modules") {
		t.Error("output should contain Modules section")
	}
	if !strings.Contains(output, "### auth (go)") {
		t.Error("output should contain auth module heading with type")
	}
	if !strings.Contains(output, "### web-ui (node)") {
		t.Error("output should contain web-ui module heading with type")
	}
	if !strings.Contains(output, "### ml-pipeline (python)") {
		t.Error("output should contain ml-pipeline module heading with type")
	}
	if !strings.Contains(output, "Provides authentication and session management") {
		t.Error("output should contain module intent text")
	}

	// Business Domains section.
	if !strings.Contains(output, "## Business Domains") {
		t.Error("output should contain Business Domains section")
	}
	if !strings.Contains(output, "### authentication") {
		t.Error("output should contain authentication zone heading")
	}
	if !strings.Contains(output, "Handles user login") {
		t.Error("output should contain zone intent")
	}
	if !strings.Contains(output, "- auth/login.go") {
		t.Error("output should list zone files")
	}
	if !strings.Contains(output, "### billing") {
		t.Error("output should contain billing zone heading")
	}

	// Coding Patterns section.
	if !strings.Contains(output, "## Coding Patterns") {
		t.Error("output should contain Coding Patterns section")
	}
	if !strings.Contains(output, "- Dependency injection via constructor functions") {
		t.Error("output should list patterns as bullet points")
	}
	if !strings.Contains(output, "- Interface-based abstractions for testability") {
		t.Error("output should contain second pattern")
	}

	// Footer.
	if !strings.Contains(output, "*Generated by Carto v0.2.0*") {
		t.Error("output should contain the generated-by footer")
	}
}

func TestGenerateCLAUDE_EmptyInput(t *testing.T) {
	input := Input{ProjectName: "EmptyProject"}
	output := GenerateCLAUDE(input)

	if !strings.Contains(output, "# EmptyProject") {
		t.Error("output should contain project name even with empty input")
	}
	if !strings.Contains(output, "## Architecture") {
		t.Error("output should contain Architecture section even when empty")
	}
	// Should not contain Modules section when there are no modules.
	if strings.Contains(output, "## Modules") {
		t.Error("output should not contain Modules section when there are no modules")
	}
	// Should not contain Business Domains section when there are no zones.
	if strings.Contains(output, "## Business Domains") {
		t.Error("output should not contain Business Domains section when there are no zones")
	}
	// Should not contain Coding Patterns section when there are no patterns.
	if strings.Contains(output, "## Coding Patterns") {
		t.Error("output should not contain Coding Patterns section when there are no patterns")
	}
	if !strings.Contains(output, "*Generated by Carto v0.2.0*") {
		t.Error("output should contain footer even with empty input")
	}
}

func TestGenerateCursorRules_ContainsSections(t *testing.T) {
	input := sampleInput()
	output := GenerateCursorRules(input)

	// Project name.
	if !strings.Contains(output, "Project: MyProject") {
		t.Error("output should contain project name")
	}

	// Architecture.
	if !strings.Contains(output, "Architecture:") {
		t.Error("output should contain Architecture label")
	}
	if !strings.Contains(output, "microservices architecture") {
		t.Error("output should contain blueprint text")
	}

	// Modules.
	if !strings.Contains(output, "Modules:") {
		t.Error("output should contain Modules label")
	}
	if !strings.Contains(output, "- auth (go): Provides authentication and session management") {
		t.Error("output should list modules in compact format")
	}
	if !strings.Contains(output, "- web-ui (node): React-based frontend") {
		t.Error("output should list web-ui module")
	}
	if !strings.Contains(output, "- ml-pipeline (python): Data processing") {
		t.Error("output should list ml-pipeline module")
	}

	// Patterns.
	if !strings.Contains(output, "Patterns:") {
		t.Error("output should contain Patterns label")
	}
	if !strings.Contains(output, "- Dependency injection via constructor functions") {
		t.Error("output should list patterns")
	}

	// Business Domains.
	if !strings.Contains(output, "Business Domains:") {
		t.Error("output should contain Business Domains label")
	}
	if !strings.Contains(output, "- authentication: Handles user login") {
		t.Error("output should list zones in compact format")
	}
	if !strings.Contains(output, "- billing: Manages subscriptions") {
		t.Error("output should list billing zone")
	}
}

func TestGenerateCursorRules_EmptyInput(t *testing.T) {
	input := Input{ProjectName: "EmptyProject"}
	output := GenerateCursorRules(input)

	if !strings.Contains(output, "Project: EmptyProject") {
		t.Error("output should contain project name even with empty input")
	}
	if !strings.Contains(output, "Architecture:") {
		t.Error("output should contain Architecture label even when empty")
	}
	// Should not contain Modules label when there are no modules.
	if strings.Contains(output, "Modules:") {
		t.Error("output should not contain Modules label when there are no modules")
	}
	// Should not contain Patterns label when there are no patterns.
	if strings.Contains(output, "Patterns:") {
		t.Error("output should not contain Patterns label when there are no patterns")
	}
	// Should not contain Business Domains label when there are no zones.
	if strings.Contains(output, "Business Domains:") {
		t.Error("output should not contain Business Domains label when there are no zones")
	}
}

func TestWriteFiles_All(t *testing.T) {
	dir := t.TempDir()
	input := sampleInput()

	err := WriteFiles(dir, input, "all")
	if err != nil {
		t.Fatalf("WriteFiles(all) returned error: %v", err)
	}

	// Verify CLAUDE.md was created.
	claudePath := filepath.Join(dir, "CLAUDE.md")
	claudeData, err := os.ReadFile(claudePath)
	if err != nil {
		t.Fatalf("CLAUDE.md not created: %v", err)
	}
	if !strings.Contains(string(claudeData), "# MyProject") {
		t.Error("CLAUDE.md should contain project name")
	}

	// Verify .cursorrules was created.
	cursorPath := filepath.Join(dir, ".cursorrules")
	cursorData, err := os.ReadFile(cursorPath)
	if err != nil {
		t.Fatalf(".cursorrules not created: %v", err)
	}
	if !strings.Contains(string(cursorData), "Project: MyProject") {
		t.Error(".cursorrules should contain project name")
	}
}

func TestWriteFiles_ClaudeOnly(t *testing.T) {
	dir := t.TempDir()
	input := sampleInput()

	err := WriteFiles(dir, input, "claude")
	if err != nil {
		t.Fatalf("WriteFiles(claude) returned error: %v", err)
	}

	// Verify CLAUDE.md was created.
	claudePath := filepath.Join(dir, "CLAUDE.md")
	if _, err := os.Stat(claudePath); err != nil {
		t.Fatalf("CLAUDE.md should exist: %v", err)
	}

	// Verify .cursorrules was NOT created.
	cursorPath := filepath.Join(dir, ".cursorrules")
	if _, err := os.Stat(cursorPath); !os.IsNotExist(err) {
		t.Error(".cursorrules should not exist when format is 'claude'")
	}
}

func TestWriteFiles_CursorOnly(t *testing.T) {
	dir := t.TempDir()
	input := sampleInput()

	err := WriteFiles(dir, input, "cursor")
	if err != nil {
		t.Fatalf("WriteFiles(cursor) returned error: %v", err)
	}

	// Verify .cursorrules was created.
	cursorPath := filepath.Join(dir, ".cursorrules")
	if _, err := os.Stat(cursorPath); err != nil {
		t.Fatalf(".cursorrules should exist: %v", err)
	}

	// Verify CLAUDE.md was NOT created.
	claudePath := filepath.Join(dir, "CLAUDE.md")
	if _, err := os.Stat(claudePath); !os.IsNotExist(err) {
		t.Error("CLAUDE.md should not exist when format is 'cursor'")
	}
}

func TestWriteFiles_InvalidFormat(t *testing.T) {
	dir := t.TempDir()
	input := sampleInput()

	err := WriteFiles(dir, input, "invalid")
	if err == nil {
		t.Fatal("WriteFiles should return error for invalid format")
	}
	if !strings.Contains(err.Error(), "unknown format") {
		t.Errorf("error should mention unknown format, got: %v", err)
	}
}

func TestWriteFiles_CreatesDirectory(t *testing.T) {
	dir := filepath.Join(t.TempDir(), "nested", "output")
	input := sampleInput()

	err := WriteFiles(dir, input, "all")
	if err != nil {
		t.Fatalf("WriteFiles should create nested directory: %v", err)
	}

	// Both files should exist.
	if _, err := os.Stat(filepath.Join(dir, "CLAUDE.md")); err != nil {
		t.Error("CLAUDE.md should exist in nested directory")
	}
	if _, err := os.Stat(filepath.Join(dir, ".cursorrules")); err != nil {
		t.Error(".cursorrules should exist in nested directory")
	}
}

func TestGenerateCLAUDE_ZoneFilesListed(t *testing.T) {
	input := Input{
		ProjectName: "Test",
		Zones: []Zone{
			{
				Name:   "payments",
				Intent: "Handles payment processing",
				Files:  []string{"pay/charge.go", "pay/refund.go", "pay/webhook.go"},
			},
		},
	}
	output := GenerateCLAUDE(input)

	// All three files should appear.
	for _, f := range input.Zones[0].Files {
		if !strings.Contains(output, "- "+f) {
			t.Errorf("output should list file %q", f)
		}
	}
}

func TestWriteFiles_ContentRoundTrip(t *testing.T) {
	dir := t.TempDir()
	input := sampleInput()

	if err := WriteFiles(dir, input, "all"); err != nil {
		t.Fatalf("WriteFiles failed: %v", err)
	}

	// Read CLAUDE.md and verify it matches GenerateCLAUDE output.
	claudeData, err := os.ReadFile(filepath.Join(dir, "CLAUDE.md"))
	if err != nil {
		t.Fatalf("failed to read CLAUDE.md: %v", err)
	}
	expected := GenerateCLAUDE(input)
	if string(claudeData) != expected {
		t.Error("CLAUDE.md content should match GenerateCLAUDE output exactly")
	}

	// Read .cursorrules and verify it matches GenerateCursorRules output.
	cursorData, err := os.ReadFile(filepath.Join(dir, ".cursorrules"))
	if err != nil {
		t.Fatalf("failed to read .cursorrules: %v", err)
	}
	expectedCursor := GenerateCursorRules(input)
	if string(cursorData) != expectedCursor {
		t.Error(".cursorrules content should match GenerateCursorRules output exactly")
	}
}
