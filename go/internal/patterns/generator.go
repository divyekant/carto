// Package patterns generates skill files (CLAUDE.md, .cursorrules) from
// discovered architectural patterns, business zones, and blueprint data
// produced during Carto indexing.
package patterns

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Input contains the data needed to generate pattern files.
type Input struct {
	ProjectName string
	Blueprint   string          // from SystemSynthesis
	Patterns    []string        // from SystemSynthesis
	Zones       []Zone          // aggregated from all modules
	Modules     []ModuleSummary // brief info about each module
}

// Zone is a business domain grouping.
type Zone struct {
	Name   string
	Intent string
	Files  []string
}

// ModuleSummary is brief info about a module.
type ModuleSummary struct {
	Name   string
	Intent string
	Type   string // "go", "node", "python", etc.
}

// GenerateCLAUDE produces a CLAUDE.md file content from the given input.
func GenerateCLAUDE(input Input) string {
	var b strings.Builder

	fmt.Fprintf(&b, "# %s\n\n", input.ProjectName)

	// Architecture section.
	b.WriteString("## Architecture\n\n")
	if input.Blueprint != "" {
		b.WriteString(input.Blueprint)
		b.WriteString("\n\n")
	}

	// Modules section.
	if len(input.Modules) > 0 {
		b.WriteString("## Modules\n\n")
		for _, m := range input.Modules {
			fmt.Fprintf(&b, "### %s (%s)\n", m.Name, m.Type)
			b.WriteString(m.Intent)
			b.WriteString("\n\n")
		}
	}

	// Business Domains section.
	if len(input.Zones) > 0 {
		b.WriteString("## Business Domains\n\n")
		for _, z := range input.Zones {
			fmt.Fprintf(&b, "### %s\n", z.Name)
			b.WriteString(z.Intent)
			b.WriteString("\n\n")
			if len(z.Files) > 0 {
				b.WriteString("Files:\n")
				for _, f := range z.Files {
					fmt.Fprintf(&b, "- %s\n", f)
				}
				b.WriteString("\n")
			}
		}
	}

	// Coding Patterns section.
	if len(input.Patterns) > 0 {
		b.WriteString("## Coding Patterns\n\n")
		for _, p := range input.Patterns {
			fmt.Fprintf(&b, "- %s\n", p)
		}
		b.WriteString("\n")
	}

	// Keeping the Index Current section.
	b.WriteString("## Keeping the Index Current\n\n")
	b.WriteString("When you make significant code changes (new features, bug fixes, refactors), ")
	b.WriteString("write a summary back to the Carto index so it stays fresh without re-indexing.\n\n")
	b.WriteString("**Source tag convention:** `carto/")
	b.WriteString(input.ProjectName)
	b.WriteString("/{module}/layer:atoms`\n\n")
	b.WriteString("**Write back a discovery:**\n")
	b.WriteString("```bash\n")
	b.WriteString("curl -s -X POST \"$MEMORIES_URL/memory/add\" \\\n")
	b.WriteString("  -H \"Content-Type: application/json\" \\\n")
	b.WriteString("  -H \"X-API-Key: $MEMORIES_API_KEY\" \\\n")
	b.WriteString("  -d '{\n")
	b.WriteString("    \"text\": \"Description of what changed and why\",\n")
	fmt.Fprintf(&b, "    \"source\": \"carto/%s/MODULE_NAME/layer:atoms\"\n", input.ProjectName)
	b.WriteString("  }'\n")
	b.WriteString("```\n\n")
	b.WriteString("Replace `MODULE_NAME` with the relevant module. ")
	b.WriteString("Use `layer:atoms` for code-level facts, `layer:wiring` for cross-component discoveries.\n\n")

	b.WriteString("---\n*Generated by Carto v0.3.0*\n")

	return b.String()
}

// GenerateCursorRules produces a .cursorrules file content from the given input.
func GenerateCursorRules(input Input) string {
	var b strings.Builder

	fmt.Fprintf(&b, "Project: %s\n\n", input.ProjectName)

	// Architecture.
	b.WriteString("Architecture:\n")
	if input.Blueprint != "" {
		b.WriteString(input.Blueprint)
	}
	b.WriteString("\n\n")

	// Modules.
	if len(input.Modules) > 0 {
		b.WriteString("Modules:\n")
		for _, m := range input.Modules {
			fmt.Fprintf(&b, "- %s (%s): %s\n", m.Name, m.Type, m.Intent)
		}
		b.WriteString("\n")
	}

	// Patterns.
	if len(input.Patterns) > 0 {
		b.WriteString("Patterns:\n")
		for _, p := range input.Patterns {
			fmt.Fprintf(&b, "- %s\n", p)
		}
		b.WriteString("\n")
	}

	// Business Domains.
	if len(input.Zones) > 0 {
		b.WriteString("Business Domains:\n")
		for _, z := range input.Zones {
			fmt.Fprintf(&b, "- %s: %s\n", z.Name, z.Intent)
		}
		b.WriteString("\n")
	}

	// Write-back instructions.
	b.WriteString("Keeping the Index Current:\n")
	b.WriteString("When making significant code changes, update the Carto index by running:\n")
	fmt.Fprintf(&b, "  curl -s -X POST \"$MEMORIES_URL/memory/add\" -H \"Content-Type: application/json\" -H \"X-API-Key: $MEMORIES_API_KEY\" -d '{\"text\": \"SUMMARY\", \"source\": \"carto/%s/MODULE/layer:atoms\"}'\n", input.ProjectName)
	b.WriteString("Replace SUMMARY with what changed and why. Replace MODULE with the relevant module name.\n")
	b.WriteString("Write back after: new features, bug fixes, refactors, or pattern discoveries.\n\n")

	return b.String()
}

// WriteFiles writes CLAUDE.md and/or .cursorrules to the given directory.
// The format parameter controls which files are written: "claude" writes only
// CLAUDE.md, "cursor" writes only .cursorrules, and "all" writes both.
func WriteFiles(dir string, input Input, format string) error {
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("patterns: cannot create directory %s: %w", dir, err)
	}

	switch format {
	case "claude":
		return writeCLAUDE(dir, input)
	case "cursor":
		return writeCursorRules(dir, input)
	case "all":
		if err := writeCLAUDE(dir, input); err != nil {
			return err
		}
		return writeCursorRules(dir, input)
	default:
		return fmt.Errorf("patterns: unknown format %q (expected claude, cursor, or all)", format)
	}
}

// writeCLAUDE writes a CLAUDE.md file to the given directory.
func writeCLAUDE(dir string, input Input) error {
	path := filepath.Join(dir, "CLAUDE.md")
	content := GenerateCLAUDE(input)
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("patterns: failed to write %s: %w", path, err)
	}
	return nil
}

// writeCursorRules writes a .cursorrules file to the given directory.
func writeCursorRules(dir string, input Input) error {
	path := filepath.Join(dir, ".cursorrules")
	content := GenerateCursorRules(input)
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		return fmt.Errorf("patterns: failed to write %s: %w", path, err)
	}
	return nil
}
