import type { CodebasePatterns, SystemNarrative, Domain, PatternRule } from './types.js';

interface GenerateOptions {
  minConfidence?: 'high' | 'medium' | 'low';
}

export class SkillGenerator {
  generateClaudeMd(
    patterns: CodebasePatterns,
    system: SystemNarrative,
    domains: Domain[],
    options: GenerateOptions = {},
  ): string {
    const minConfidence = options.minConfidence ?? 'medium';
    const filter = (rules: PatternRule[]) => this.filterByConfidence(rules, minConfidence);

    const sections: string[] = [];

    sections.push('# Codebase Intelligence (Auto-generated by Codex)');
    sections.push('');
    sections.push('> This file was auto-generated by Codex codebase indexer. It encodes discovered patterns and conventions.');
    sections.push('> Re-run `codex patterns .` to update after significant codebase changes.');
    sections.push('');

    // System overview
    sections.push('## System Overview');
    sections.push('');
    sections.push(system.overview);
    sections.push('');
    sections.push(`**Architecture:** ${system.architecture}`);
    sections.push(`**Tech Stack:** ${system.techStack.join(', ')}`);
    sections.push(`**Entry Points:** ${system.entryPoints.join(', ')}`);
    sections.push('');

    // Domains
    if (domains.length > 0) {
      sections.push('## Domains');
      sections.push('');
      for (const domain of domains) {
        sections.push(`### ${domain.domain}`);
        sections.push('');
        sections.push(domain.description);
        sections.push(`- **Entry Points:** ${domain.entryPoints.join(', ')}`);
        sections.push(`- **Data Flow:** ${domain.dataFlow}`);
        if (domain.concerns.length > 0) {
          sections.push(`- **Known Concerns:** ${domain.concerns.join('; ')}`);
        }
        sections.push('');
      }
    }

    // Conventions
    sections.push('## Coding Conventions');
    sections.push('');
    sections.push('Follow these patterns when writing new code:');
    sections.push('');

    this.addPatternSection(sections, 'Naming', filter(patterns.naming));
    this.addPatternSection(sections, 'File Organization', filter(patterns.fileOrganization));
    this.addPatternSection(sections, 'Architecture', filter(patterns.architecture));
    this.addPatternSection(sections, 'Imports', filter(patterns.imports));
    this.addPatternSection(sections, 'Error Handling', filter(patterns.errorHandling));
    this.addPatternSection(sections, 'Testing', filter(patterns.testing));
    this.addPatternSection(sections, 'Domain Boundaries', filter(patterns.domainBoundaries));

    return sections.join('\n');
  }

  generateCursorRules(
    patterns: CodebasePatterns,
    system: SystemNarrative,
    domains: Domain[],
    options: GenerateOptions = {},
  ): string {
    const minConfidence = options.minConfidence ?? 'medium';
    const filter = (rules: PatternRule[]) => this.filterByConfidence(rules, minConfidence);

    const lines: string[] = [];
    lines.push(`# Project: ${system.overview.split('.')[0]}`);
    lines.push('');
    lines.push(`Tech Stack: ${system.techStack.join(', ')}`);
    lines.push(`Architecture: ${system.architecture}`);
    lines.push('');
    lines.push('## Rules');
    lines.push('');

    const allRules = [
      ...filter(patterns.naming),
      ...filter(patterns.fileOrganization),
      ...filter(patterns.architecture),
      ...filter(patterns.imports),
      ...filter(patterns.errorHandling),
      ...filter(patterns.testing),
      ...filter(patterns.domainBoundaries),
    ];

    for (const rule of allRules) {
      lines.push(`- ${rule.rule}`);
    }

    if (domains.length > 0) {
      lines.push('');
      lines.push('## Domains');
      for (const d of domains) {
        lines.push(`- ${d.domain}: ${d.description.split('.')[0]}`);
      }
    }

    return lines.join('\n');
  }

  private addPatternSection(sections: string[], title: string, rules: PatternRule[]): void {
    if (rules.length === 0) return;

    sections.push(`### ${title}`);
    sections.push('');
    for (const rule of rules) {
      const examples = rule.examples.length > 0 ? ` (e.g., ${rule.examples.join(', ')})` : '';
      sections.push(`- ${rule.rule}${examples}`);
    }
    sections.push('');
  }

  private filterByConfidence(rules: PatternRule[], min: 'high' | 'medium' | 'low'): PatternRule[] {
    const levels = { high: 3, medium: 2, low: 1 };
    const minLevel = levels[min];
    return rules.filter(r => levels[r.confidence] >= minLevel);
  }
}
